{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport {onMount} from 'svelte';\n\timport _ from 'lodash';\n\timport {getPixels, matchImages, getImgUrl} from './pixels';\n\timport {extractCSSConsts, createGenerateRandomStyle, renderCSS, absoluteCoverPosition, pretty} from './css'\n\timport {initPool, evolvePool} from './genetic';\n\timport {genPickRandom, randomInt} from './random'\n\texport let html = '<div></div>';\n\texport let style = '';\n\texport let semantic = '<div></div>';\n\t$: source = `<style>${style}</style>${html}`\n\tlet canvas;\n\tlet container = null;\n\tlet pool;\n\tlet render = true;\n\tlet fitnessFunc = null;\n\tlet genStyle = null;\n\tlet randomMutationType = genPickRandom({\n\t\tADD: 15,\n\t\tREMOVE: 25,\n\t\tREPLACE: 5,\n\t\tTWEAK: 10,\n\t\tSHUFFLE: 1,\n\t\t// CROSS: 1\n\t})\n\tlet display = null\n\tlet ctx = null;\n\tconst defaultPrePostPost = [{selector: 'root::before', ...absoluteCoverPosition},{selector: 'root::after', ...absoluteCoverPosition}]\n\n\tconst pre = `span[class$=\"label\"] {color:transparent !important;}\n\t\t\t`\n\t$: best = `<style>${pretty(pre + renderCSS(defaultPrePostPost.concat(display ? display.genes: [])), {parser:'css'})}</style>`\n\n\tlet mutateFunc = null;\n\t\n\tasync function init (){\n\t\tconst styleNode = container.children[0];\n\t\tconst origNode = container.children[1];\n\t\tconst { offsetWidth, offsetHeight, className, outerHTML } = origNode;\n\t\tconsole.log({ offsetWidth, offsetHeight})\n\t\tcanvas.style = `width: ${offsetWidth + 40}px; height: ${offsetHeight + 40}px;`;\n\t\tconst cssConsts = await extractCSSConsts(styleNode);\n\t\tconst pixels = await getPixels(offsetWidth, offsetHeight, html, pre + style);\n\t\tgenStyle = createGenerateRandomStyle({...cssConsts, classNames:['root'/*,'link','label'*/]});//,\n\t\tctx = canvas.getContext('2d');\n\t\t// for (let i = 0; i < pixels.data.length; i+= 4) {\n\t\t// \tpixels.data[i] = pixels.data[i+3] = 255;\n\t\t// \tpixels.data[i+1] = pixels.data[i+2] = 0\n\t\t// }\n\t\tctx.putImageData(pixels, 0, 0);\n\n\t\tfitnessFunc = async genes => {\n\t\t\tconst newPixels = await getPixels(offsetWidth, offsetHeight, semantic, pre+renderCSS(defaultPrePostPost.concat(genes)));\n\t\t\tif (render) {\n\t\t\t\tctx.putImageData(newPixels, 0, 0);\n\t\t\t}\n\t\t\treturn matchImages(newPixels, pixels) + genes.length /1000.0;\n\t\t};\n\t\tmutateFunc = (a, b) => {\n\t\t\tlet type = randomMutationType();\n\t\t\tif (a.length < 2 ) {\n\t\t\t\ttype = 'ADD';\n\t\t\t} else if (a.length > 12 && type === 'ADD') {\n\t\t\t\ttype = 'REMOVE';\n\t\t\t}\n\t\t\tconst idx = randomInt(a.length);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'REPLACE':\n\t\t\t\t\treturn a.slice(0,idx).concat([genStyle()], a.slice(idx + 1))\n\t\t\t\tcase 'ADD':\n\t\t\t\t\treturn a.slice(0,idx).concat([genStyle()], a.slice(idx))\n\t\t\t\t// case 'CROSS':\n\t\t\t\t// \treturn a.concat(b).sort(() => Math.random() - 0.5).slice(0,a.length);\n\t\t\t\tcase 'REMOVE':\n\t\t\t\t\treturn a.slice(0,idx).concat(a.slice(idx + 1));\n\t\t\t\tcase 'SHUFFLE':\n\t\t\t\t\treturn _.shuffle(a.slice());\n\t\t\t\tcase 'TWEAK':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst alt = genStyle(a[idx].type, a[idx].selector).value.split(' ');\n\t\t\t\t\t\tconst val = a[idx].value.split(' ');\n\t\t\t\t\t\tfor (let i = 0;i < Math.max(val.length / 4, 1);i++) {\n\t\t\t\t\t\t\tconst part = randomInt(val.length);\n\t\t\t\t\t\t\tval[part] = alt[part];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a.slice(0,idx).concat([{...a[idx], value: val.join(' ')}], a.slice(idx + 1))\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t}\n\t\t}\n\t\n\t\tpool = initPool(() => [ genStyle()]);\n\t\t// pool = initPool(() => [genStyle()]);\n\t\tdisplay = pool.pool[0];\n\n\t}\n\n\tonMount(() => {\n\t\tinit();\n\t})\n\n\tlet evolving = false;\n\n\tlet timer = null;\n\tlet lastTimer = null;\n\n\tasync function runEpoch() {\n\t\t// console.log('running');\n\t\tconsole.log({best:pool.pool[0].score,worst:pool.pool[pool.pool.length - 1].score, time: lastTimer ? performance.now() - lastTimer : 0})\n\t\tlastTimer = performance.now();\n\t\tpool = await evolvePool(pool, fitnessFunc, mutateFunc );\n\t\twindow.pool = pool;\n\t\tdisplay = pool.pool[0];\n\t\t// console.log(pool.pool.map(t => t.score));\n\t\tif (timer) {\n\t\t\ttimer = setTimeout(runEpoch,0);\n\t\t}\n\t}\n\n\tfunction toggleEvolve() {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\n\t\t\ttimer = null;\n\t\t} else {\n\t\t\ttimer = setTimeout(runEpoch,0)\n\t\t}\n\t}\n</script>\n\n<style>\n\tsection {\n\t\tposition: absolute;\n\t\ttop: 25%;\n\t\tleft: 25%;\n\t}\n\tfooter {\n\t\tposition: absolute;\n\t\ttop: 75%;\n\t\tleft: 25;\n\t}\n\tdiv {\n\t\t\n\t}\n</style>\n\n<div>\n\t<h1>CSS Evolution!</h1>\n\t<button on:click={toggleEvolve}>Run</button>\n\t<br>\n\t<input type=checkbox bind:checked={render}>Render\n\t<span>Best score:{display && display.score} Generation:{display && pool.generation}</span>\n\t<br>\n\t<section bind:this={container}>\n\t\t{@html source}\n\t</section>\n\t<sidebar>\n\t\t<canvas bind:this={canvas}/>\n\t</sidebar>\n\t<footer>\n\t\t{@html best}\n\t\t<div style=\"padding:20px\">\n\t\t\t{@html semantic}\n\t\t</div>\n\t\t<pre>{best}</pre>\n\t</footer>\n</div>\n"
  ],
  "names": [],
  "mappings": "AAqIC,OAAO,cAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,GAAG,AACV,CAAC,AACD,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,IAAI,CAAE,EAAE,AACT,CAAC"
}